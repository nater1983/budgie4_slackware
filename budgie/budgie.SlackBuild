#!/bin/sh
# Copyright 2011, 2012, 2017, 2018, 2020  Patrick J. Volkerding, Sebeka, MN, USA
# All rights reserved.
#
# Adapted by Nathaniel Russell <naterussell83@gmail.com> for modular Budgie build.
# Budgie.SlackBuild Script

# Set up general build options
CLEANUP=${CLEANUP:-"yes"}       # Clean up after build
UPGRADE=${UPGRADE:-"yes"}        # Upgrade package after successful build
PRECHECK=${PRECHECK:-"no"}       # Perform a pre-check of sources
CHECKOUT=${CHECKOUT:-"no"}       # Don't let the script checkout missing sources by default
GRACETME=${GRACETME:-"10"}      # Grace time before build starts
SKIPBUILT=${SKIPBUILT:-"no"}    # Skip already built packages
EXITFAIL=${EXITFAIL:-"yes"}      # Exit on build failure

# Function to get base name of the package (remove .tar extensions)
pkgbase() {
  PKGEXT=$(echo $1 | rev | cut -f 1 -d . | rev)
  case $PKGEXT in
    'gz' ) PKGRETURN=$(basename $1 .tar.gz) ;;
    'bz2' ) PKGRETURN=$(basename $1 .tar.bz2) ;;
    'xz' ) PKGRETURN=$(basename $1 .tar.xz) ;;
    'deb' ) PKGRETURN=$(basename $1 .deb) ;;
    *) PKGRETURN=$(basename $1) ;;
  esac
  echo $PKGRETURN
}

# Set initial directory variables
cd "$(dirname "$0")" ; CWD=$(pwd)

TMP=${TMP:-/home}
SLACK_BUDGIE_BUILD_DIR=${BUDGIE_BUILD_DIR:-$TMP/build}
mkdir -p "$SLACK_BUDGIE_BUILD_DIR"

extract_archive() {
  local src_archive
  src_archive=$(find "$CWD/src" -name "${1}" | tail -1)

  if [[ "$src_archive" == *.deb ]]; then
    local tempdir
    tempdir=$(mktemp -d)
    ( cd "$tempdir" && ar x "$src_archive" )
    local data_archive
    data_archive=$(find "$tempdir" -name 'data.tar.*' | head -n 1)

    mkdir -p "$(pkgbase "$1")"
    tar -C "$tempdir" -xf "$data_archive" || return 1
    find "$tempdir" -mindepth 1 -maxdepth 1 -exec mv -t "$(pkgbase "$1")" -- {} +
    rm -rf "$tempdir"
    return 0
  fi

  if [ "$(tar -tf "$src_archive" | grep -o '^[^/]\+' | sort -u | wc -l)" -eq 1 ]; then
    tar -xf "$src_archive" || return 1
    local topdir
    topdir="$(tar -tf "$src_archive" | grep -o '^[^/]\+' | sort -u)"
    if [ "${topdir}" != "$(pkgbase "$1")" ]; then
      mv "${topdir}" "$(pkgbase "$1")"
    fi
  else
    mkdir -p "$(pkgbase "$1")"
    tar -C "$(pkgbase "$1")" -xf "$src_archive" || return 1
  fi
}

fix_perms() {
  local target_dir=$1
  [ -z "$target_dir" ] && target_dir="."
  chown -R root:root "$target_dir"
  find "$target_dir" \
   \( -perm 777 -o -perm 775 -o -perm 750 -o -perm 711 -o -perm 555 -o -perm 511 \) \
   -exec chmod 755 {} \+ -o \
   \( -perm 666 -o -perm 664 -o -perm 640 -o -perm 600 -o -perm 444 -o -perm 440 -o -perm 400 \) \
   -exec chmod 644 {} \+
}

strip_binaries() {
  local target_dir=$1
  [ -z "$target_dir" ] && target_dir="."
  find "$target_dir" | xargs file | grep "executable" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
  find "$target_dir" | xargs file | grep "shared object" | grep ELF | cut -f 1 -d : | xargs strip --strip-unneeded 2> /dev/null
  find "$target_dir" | xargs file | grep "current ar archive" | grep ELF | cut -f 1 -d : | xargs strip -g 2> /dev/null
}

process_man_pages() {
  if [ -d "usr/share/man" ]; then
    mkdir -p usr/man
    cp -av usr/share/man/* usr/man/
    rm -fr usr/share/man
    find usr/man -type f -name "*.gz" | while read -r gzfile; do
      uncompressed="${gzfile%.gz}"
      [ -f "$uncompressed" ] && rm -v "$gzfile"
    done
  fi

  if [ -d "usr/man" ]; then
    ( cd usr/man
      for manpagedir in $(find . -type d -name "man*"); do
        ( cd "$manpagedir"
          for eachpage in $(find . -type l -maxdepth 1); do
            ln -s "$(readlink "$eachpage").gz" "$eachpage.gz"
            rm "$eachpage"
          done
          gzip -9 *.*
        )
      done
    )
  fi
}

process_info_pages() {
  if [ -d "usr/share/info" ]; then
    mkdir -p usr/info
    mv usr/share/info/* usr/info/
    rmdir usr/share/info
  fi

  if [ -d "usr/info" ]; then
    ( cd usr/info
      rm -f dir
      gzip -9 *
    )
  fi
}

no_usr_share_doc() {
  if [ -d "usr/share/doc" ]; then
    mkdir -p "usr/doc/${DOCNAME}-${PACKAGE_VERSION}"
    mv usr/share/doc/* "usr/doc/${DOCNAME}-${PACKAGE_VERSION}"
    rmdir usr/share/doc
  fi
}

no_usr_doc_prgnam() {
  if [ -d "usr/doc/${DOCNAME}" ]; then
    mv "usr/doc/${DOCNAME}/"* "usr/doc/${DOCNAME}-${PACKAGE_VERSION}"
    rmdir "usr/doc/${DOCNAME}"
  fi
}

no_usr_dups() {
  if [ -d "usr/doc/${DOCNAME}-${PACKAGE_VERSION}/${DOCNAME}-${PACKAGE_VERSION}" ]; then
    rm -fr "usr/doc/${DOCNAME}-${PACKAGE_VERSION}/${DOCNAME}-${PACKAGE_VERSION}"
  fi
}

no_systemd() {
  for path in usr/lib/systemd usr/lib64/systemd; do
    [ -d "$path" ] && rm -rf "$path"
  done
}

precheck() {
  RETVAL=0
  for SRCFILE in $(find "$CWD/src" -type f \( -name "*.tar.?z*" -o -name "*.deb" \) | grep -vE ".asc$|.sig$"); do
    PKGSRC=$(echo "$SRCFILE" | rev | cut -f2- -d- | cut -f1,2 -d/ | rev)
    PKGBASE=$(basename "$(grep -lw "$PKGSRC" "$CWD"/pkgsrc/* 2>/dev/null)" 2>/dev/null)
    [ -z "$PKGBASE" ] && PKGBASE=$(echo "$(basename "$SRCFILE")" | rev | cut -f2- -d- | rev)
    PKGTGT=$(grep -w "${PKGBASE}$" modules/* 2>/dev/null)
    if [ -n "$(echo "$PKGTGT" | cut -d: -f2- | grep "^ *#")" ]; then
      echo "Source file '$(basename "$SRCFILE")' is commented out: ($PKGTGT) !"
    elif grep -v "^ *#" "$CWD/package-blacklist" | grep -wq "${PKGBASE}$" ; then
      echo "Source file '$(basename "$SRCFILE")' is on the package-blacklist ($PKGBASE) !"
    elif ! cat modules/* 2>/dev/null | grep -v "^ *#" | grep -wq "${PKGBASE}$" ; then
      echo "Source file '$(basename "$SRCFILE")' is not mentioned in 'modules' ($PKGBASE) !"
      RETVAL=1
    fi
  done

  PKGDUP=$(cat "$CWD"/modules/* 2>/dev/null | grep -v "^ *#" | grep -v "^$" | sort | uniq -d)
  [ -n "$PKGDUP" ] && echo "Multiply-defined package names: '$(echo "$PKGDUP")'" && RETVAL=1
  unset PKGDUP

  for MODPKG in $(cat "$CWD"/modules/* 2>/dev/null | grep -v "^ *#"); do
    if [ -f "$CWD/pkgsrc/$MODPKG" ]; then
      MODBASE=$(basename "$(cat "$CWD/pkgsrc/$MODPKG")")
      MODLOC=$(dirname "$(cat "$CWD/pkgsrc/$MODPKG")")/
    else
      MODBASE=$MODPKG
      MODLOC=""
    fi

    MODSRC=$(find "$CWD/src/$MODLOC" -name "$MODBASE-*.tar.*" | grep -vE ".asc$|.sig$" | grep -E "$MODBASE-[^-]+.tar.*$|$MODBASE-[0-9].+.tar.*$")
    if [ -z "$MODSRC" ]; then
      echo "Module '$MODPKG' does not have a matching source tarball ($MODLOC$MODBASE)!"
      if [ "$CHECKOUT" = "yes" ]; then
        THEDATE=$(date +%Y%m%d)
        echo "Checking out ${MODLOC}:${MODBASE} at date ${THEDATE}."
        "$CWD/budgie_checkout.sh" -c -d "${THEDATE}" -o "$CWD/src" "${MODLOC}:${MODBASE}"
        RETVAL=$?
        [ $RETVAL -ne 0 ] && mv "$CWD/src/$MODLOC/${MODBASE}-${THEDATE}git.tar.xz" "$CWD/src/$MODLOC/${MODBASE}-${THEDATE}git.tar.xz.failed" 2>/dev/null
      else
        RETVAL=1
      fi
    fi

    [ -z "$(find "$CWD/slack-desc" -name "${MODPKG}")" ] && echo "Module '$MODPKG' does not have a slack-desc file !" && RETVAL=1
  done

  [ $RETVAL -eq 0 ] && echo "Check complete, build starts in ${GRACETME} seconds.." && sleep "${GRACETME}" || (echo "Precheck failed with error code '$RETVAL'." ; exit 1)
}

# Build functions (build_mod_pkg and deterministic_build) remain identical
# Only message changes from Pantheon -> Budgie

# MAIN PART #
[ -r ./budgie.options ] && . ./budgie.options

BUDGIEMODS=" \
  blacklist \
  gnome \
  budgie \
  "

if [ -z "$1" ]; then
  MODQUEUE=$BUDGIEMODS
else
  MODQUEUE="$*"
fi

[ "$PRECHECK" = "yes" ] && precheck

for module in $MODQUEUE ; do
  echo "SlackBuild processing module '$module'"
  deterministic_build "$module"
  if [ $? = 0 ] && [ "$CLEANUP" = "yes" ]; then
    find "${SLACK_BUDGIE_BUILD_DIR}/$(echo "$module" | cut -f1 -d:)" -type d -mindepth 1 -maxdepth 1 | xargs rm -rf
  else
    echo "${module} failed to build."
    [ "$EXITFAIL" = "yes" ] && exit 1
  fi
  cd - > /dev/null
done

exit 0
